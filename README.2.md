> a video showcasing how pnpm autocompletions works on a test cli command like `my-cli`

# tab

> instant feedback when hitting [TAB] in your cli tool

as cli tooling authors, if we can spare our users a second or two by not checking the documentation or writing the `-h` option, we're doing them a huge favor. the unconscious loves hitting the [TAB] key. it always expects feedback. so it feels dissappointing when hitting that key in the terminal but then nothing happens. that frustration is apparent across the whole javascript cli tooling ecosystem.

autocompletions are the solution to not break the user's flow. the issue is they're not simple to add. `zsh` expects them in a way, and `bash` in another way. then where do we provide them so the shell environment parses them? too many headaches to ease the user's experience. whether it's worth it or not is out of the question. because tab is the solution to this complexity.  

`my-cli.ts`:
```typescript
import t from '@bombsh/tab'

t.name('my-cli')

t.command('start', 'start the development server')

if (process.argv[2] === 'complete') {
  const [shell, ...args] = process.argv.slice(3)
  if (shell === '--') {
    t.parse(args)
  } else {
    t.setup(shell, x)
  }
}
```

this `my-cli.ts` would be equipped with all the tools required to provide autocompletions. 

```bash
node my-cli.ts complete -- "st"
```
```
start   start the development server
:0
```

this output was generated by the `t.parse` method to autocomplete "st" to "start". 

obviously, the user won't be running that command directly in their terminal. they'd be running something like this. 

```bash
source <(node my-cli.ts complete zsh) 
```

now whenever the shell sees `my-cli`, it would bring the autocompletions we wrote for this cli tool. the `node my-cli.ts complete zsh` part would output the zsh script that loads the autocompletions provided by `t.parse` which then would be executed using `source`.

the autocompletions are only lived through the current session. to set them up across all of terminal sessions, the autocompletion script should be injected in the `.zshrc` file.

```bash
my-cli complete zsh > ~/completion-for-my-cli.zsh && echo 'source ~/completion-for-my-cli.zsh' >> ~/.zshrc
```

this is an example of autocompletions on a global cli command that is usually installed using the `-g` flag (e.g. `npm add -g my-cli`) which is available across the computer. 

---

while working on tab, we came to the realization that most javascript clis are not global cli commands but rather, per-project dependencies. 

for instance, vite won't be installed globally and instead it'd be always installed on a project. here's an example usage:

```bash
pnpm vite -h
```

so in this case, a computer might have hundreds of vite instances each installed separately and potentially from different versions on different projects. 

we were looking for a fluid strategy that would be able to load the autocompletions from each of these dependencies on a per-project basis. 

and that made us develop our own autocompletion abstraction over npm, pnpm and yarn. this would help tab identify which binaries are avaialble in a project and which of these binaries provide autocompletions. so the user would not have to `source` anything or inject any script in their `.zshrc`. 

they'd only have to run this command once and inject it in their shell config. 

```bash
echo 'eval "$(npx --prefer-offline @bombsh/tab pnpm zsh)"' >> ~/.zshrc
```

--- 

```typescript
import t from '@bombsh/tab'

t.option('help', 'list available commands') // Command (Root) 

t.command('start', 'start the development server') // Command ('start')
 .option('port', 'specify the port number') // Command ('port')

t.parse(process.argv.slice(3)) 

t.setup(process.argv[2], x)
```